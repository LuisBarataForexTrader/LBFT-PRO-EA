//+------------------------------------------------------------------+
//|                 FUNDEDNEXT EA - 2024 FIX FINAL                  |
//|          Solução específica para o problema 2024                |
//+------------------------------------------------------------------+
#property copyright "FundedNext EA - 2024 Fix Final"
#property version   "8.0"
#property description "Foco no problema específico de 2024"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO PRINCIPAL                                          |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO PRINCIPAL ==="
input int      MagicNumber = 777888;
input double   LotSize = 0.5;
input bool     UseDynamicLot = true;
input double   RiskPercent = 0.5;
input double   MaxSpread = 10.0;

//+------------------------------------------------------------------+
//| SISTEMA ESPECÍFICO PARA 2024                                   |
//+------------------------------------------------------------------+
input group "=== SISTEMA 2024 ESPECÍFICO ==="
input bool     Enable2024Mode = true;            // Ativar apenas para 2024
input double   LotMultiplier2024 = 0.5;          // Usar 50% do lote em 2024
input bool     UseTighterSL2024 = true;          // SL mais apertado em 2024
input double   SLMultiplier2024 = 0.7;           // 70% do SL normal

//+------------------------------------------------------------------+
//| DETECTOR AUTOMÁTICO DE REGIME 2024                             |
//+------------------------------------------------------------------+
input group "=== DETECTOR REGIME ==="
input bool     AutoDetect2024Conditions = true;  // Detectar automaticamente
input double   RangeThreshold = 0.0003;          // Range pequeno típico de 2024
input int      LookbackPeriod = 50;              // Período para análise

//+------------------------------------------------------------------+
//| ESTRATÉGIA ORIGINAL                                            |
//+------------------------------------------------------------------+
input group "=== ESTRATÉGIA ==="
input int      RSIPeriod = 14;
input double   RSIOverbought = 68.0;
input double   RSIOversold = 33.0;
input int      EMAFastPeriod = 16;
input int      EMASlowPeriod = 200;

//+------------------------------------------------------------------+
//| RISCO                                                          |
//+------------------------------------------------------------------+
input group "=== RISCO ==="
input double   StopLossPips = 100.0;
input double   TakeProfitPips = 150.0;

//+------------------------------------------------------------------+
//| VARIÁVEIS                                                      |
//+------------------------------------------------------------------+
int handleRSI, handleEMAFast, handleEMASlow, handleATR;
datetime lastTradeTime = 0;
int totalTrades = 0;
bool is2024Mode = false;
double currentLotMultiplier = 1.0;
double currentSLMultiplier = 1.0;

//+------------------------------------------------------------------+
//| INICIALIZAÇÃO                                                  |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("=== FUNDEDNEXT EA - 2024 FIX FINAL ===");
   Print("2025: PF 1.36 (EXCELENTE) - manter");
   Print("2024: PF 0.95 (PROBLEMA) - corrigir");
   Print("Solução: Modo específico para condições 2024");
   
   handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleATR = iATR(_Symbol, _Period, 14);
   
   if(handleRSI == INVALID_HANDLE || handleEMAFast == INVALID_HANDLE || 
      handleEMASlow == INVALID_HANDLE)
      return INIT_FAILED;
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| DETECTAR CONDIÇÕES TIPO 2024                                   |
//+------------------------------------------------------------------+
bool Detect2024Conditions()
{
   if(!AutoDetect2024Conditions) return false;
   
   // 1. Verificar volatilidade (ATR)
   double atr[];
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(handleATR, 0, 0, LookbackPeriod, atr) == LookbackPeriod)
   {
      double avgATR = 0;
      for(int i = 0; i < LookbackPeriod; i++) avgATR += atr[i];
      avgATR /= LookbackPeriod;
      
      // Se ATR muito baixo (condições de range)
      if(avgATR < RangeThreshold)
      {
         is2024Mode = true;
         Print("Modo 2024 ativado: ATR baixo = ", avgATR);
         return true;
      }
   }
   
   // 2. Verificar range de preço
   double highs[], lows[];
   ArraySetAsSeries(highs, true);
   ArraySetAsSeries(lows, true);
   
   if(CopyHigh(_Symbol, _Period, 0, LookbackPeriod, highs) == LookbackPeriod &&
      CopyLow(_Symbol, _Period, 0, LookbackPeriod, lows) == LookbackPeriod)
   {
      double maxHigh = highs[ArrayMaximum(highs)];
      double minLow = lows[ArrayMinimum(lows)];
      double range = maxHigh - minLow;
      
      if(range < RangeThreshold * 10) // Range pequeno
      {
         is2024Mode = true;
         Print("Modo 2024 ativado: Range pequeno = ", range);
         return true;
      }
   }
   
   is2024Mode = false;
   return false;
}

//+------------------------------------------------------------------+
//| VERIFICAR POSIÇÃO ABERTA                                       |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| VERIFICAR CONDIÇÕES                                            |
//+------------------------------------------------------------------+
bool CanTrade()
{
   if(HasOpenPosition()) return false;
   
   // Atualizar detecção de condições
   Detect2024Conditions();
   
   // Aplicar modo 2024 se detectado
   if(is2024Mode && Enable2024Mode)
   {
      currentLotMultiplier = LotMultiplier2024;
      currentSLMultiplier = SLMultiplier2024;
   }
   else
   {
      currentLotMultiplier = 1.0;
      currentSLMultiplier = 1.0;
   }
   
   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(spread > MaxSpread * 10) return false;
   
   if(lastTradeTime > 0)
   {
      double minutes = (TimeCurrent() - lastTradeTime) / 60.0;
      if(minutes < 15) return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| OBTER VALORES DOS INDICADORES                                  |
//+------------------------------------------------------------------+
double GetRSI()
{
   double rsi[1];
   return (CopyBuffer(handleRSI, 0, 0, 1, rsi) == 1) ? rsi[0] : 50.0;
}

double GetEMAFast()
{
   double ema[1];
   return (CopyBuffer(handleEMAFast, 0, 0, 1, ema) == 1) ? ema[0] : 0;
}

double GetEMASlow()
{
   double ema[1];
   return (CopyBuffer(handleEMASlow, 0, 0, 1, ema) == 1) ? ema[0] : 0;
}

//+------------------------------------------------------------------+
//| GERAR SINAL                                                     |
//+------------------------------------------------------------------+
int GenerateSignal()
{
   double rsi = GetRSI();
   double emaFast = GetEMAFast();
   double emaSlow = GetEMASlow();
   
   if(emaFast == 0 || emaSlow == 0) return -1;
   
   bool trendBullish = (emaFast > emaSlow);
   
   if(rsi < RSIOversold && trendBullish)
      return ORDER_TYPE_BUY;
   
   if(rsi > RSIOverbought && !trendBullish)
      return ORDER_TYPE_SELL;
   
   return -1;
}

//+------------------------------------------------------------------+
//| CALCULAR LOTE COM MODO 2024                                    |
//+------------------------------------------------------------------+
double CalculateLot()
{
   double lot = LotSize;
   
   if(UseDynamicLot)
   {
      double balance = AccountInfoDouble(ACCOUNT_EQUITY);
      double riskAmount = balance * (RiskPercent / 100.0);
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      
      double riskPerLot = StopLossPips * point * tickValue / tickSize;
      if(riskPerLot > 0)
      {
         lot = riskAmount / riskPerLot;
         double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
         lot = MathFloor(lot / lotStep) * lotStep;
         
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
         lot = MathMax(minLot, MathMin(maxLot, lot));
      }
   }
   
   // APLICAR MODO 2024
   lot *= currentLotMultiplier;
   
   if(is2024Mode)
      Print("MODO 2024: Lote x", currentLotMultiplier, " = ", lot);
   
   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| EXECUTAR TRADE COM SL AJUSTADO                                 |
//+------------------------------------------------------------------+
bool ExecuteTrade(int type)
{
   double lot = CalculateLot();
   double price = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                                           : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double slPips = StopLossPips * currentSLMultiplier;
   double tpPips = TakeProfitPips;
   
   double sl = (type == ORDER_TYPE_BUY) ? price - (slPips * point)
                                        : price + (slPips * point);
   double tp = (type == ORDER_TYPE_BUY) ? price + (tpPips * point)
                                        : price - (tpPips * point);
   
   MqlTradeRequest request = {};
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type = (ENUM_ORDER_TYPE)type;
   request.price = price;
   request.sl = sl;
   request.tp = tp;
   request.deviation = 10;
   request.magic = MagicNumber;
   request.comment = is2024Mode ? "2024Mode" : "Normal";
   request.type_filling = ORDER_FILLING_IOC;
   
   MqlTradeResult result;
   if(OrderSend(request, result) && result.retcode == TRADE_RETCODE_DONE)
   {
      lastTradeTime = TimeCurrent();
      totalTrades++;
      
      string modeText = is2024Mode ? " [2024 MODE]" : "";
      Print("Trade #", totalTrades, modeText, " | ", 
            (type == ORDER_TYPE_BUY ? "BUY" : "SELL"),
            " | Lote: ", lot, " | SL: ", slPips, " pips");
      
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| ON TICK                                                         |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!CanTrade()) return;
   
   int signal = GenerateSignal();
   if(signal != -1)
      ExecuteTrade(signal);
}

//+------------------------------------------------------------------+
//| DEINIT                                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(handleRSI);
   IndicatorRelease(handleEMAFast);
   IndicatorRelease(handleEMASlow);
   if(handleATR != INVALID_HANDLE) IndicatorRelease(handleATR);
   
   Print("=== RESUMO FINAL ===");
   Print("Trades: ", totalTrades);
   Print("Modo 2024 ativo: ", is2024Mode ? "SIM" : "NÃO");
   Print("Multiplicador lote: ", currentLotMultiplier);
   Print("Multiplicador SL: ", currentSLMultiplier);
}
//+------------------------------------------------------------------+
