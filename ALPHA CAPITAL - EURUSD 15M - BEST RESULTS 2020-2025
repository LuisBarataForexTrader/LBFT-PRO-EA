//+------------------------------------------------------------------+
//|                ALPHA CAPITAL - EURUSD 15M - BEST RESULTS 2020-2025                 |
//|    Combina estratégia original com otimizações para range     |
//+------------------------------------------------------------------+
#property copyright "FundedNext Hybrid"
#property version   "17.0"
#property description "Estratégia original + otimizações range 2024"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO PRINCIPAL (ORIGINAL)                              |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO PRINCIPAL ==="
input int      MagicNumber = 777888;
input double   LotSize = 0.5;
input bool     UseDynamicLot = true;
input double   RiskPercent = 0.5;    // ORIGINAL: 0.5% (mantém 2020-2021, 2022, 2025)
input double   MaxSpread = 10.0;
input int      MaxTradesPerDay = 5;  // ORIGINAL: 5 trades/dia

//+------------------------------------------------------------------+
//| ESTRATÉGIA ORIGINAL (NÃO MUDAR)                               |
//+------------------------------------------------------------------+
input group "=== ESTRATÉGIA ORIGINAL ==="
input int      RSIPeriod = 14;       // ORIGINAL: 14
input double   RSIOverbought = 68.0; // ORIGINAL: 68
input double   RSIOversold = 33.0;   // ORIGINAL: 33
input int      EMAFastPeriod = 16;   // ORIGINAL: 16
input int      EMASlowPeriod = 200;  // ORIGINAL: 200

//+------------------------------------------------------------------+
//| RISCO ORIGINAL                                                 |
//+------------------------------------------------------------------+
input group "=== RISCO ORIGINAL ==="
input double   StopLossPips = 100.0;   // ORIGINAL: 100 pips
input double   TakeProfitPips = 150.0; // ORIGINAL: 150 pips

//+------------------------------------------------------------------+
//| PARÂMETROS OTIMIZADOS PARA RANGE (2024)                       |
//+------------------------------------------------------------------+
input group "=== PARÂMETROS RANGE 2024 (1.56 PF) ==="
input bool     EnableRangeMode = true;       // Ativar detecção de range
input double   RangeLotMultiplier = 0.8;     // 80% do lote (OTIMIZADO)
input double   RangeSLMultiplier = 0.75;     // SL 75 pips (OTIMIZADO)
input double   RangeTPMultiplier = 0.7;      // TP 105 pips (OTIMIZADO)
input double   RangeRiskPercent = 0.8;       // 0.8% risco (OTIMIZADO)
input int      RangeMaxTrades = 8;           // 8 trades/dia (OTIMIZADO)

//+------------------------------------------------------------------+
//| DETECTOR DE RANGE (ATIVAR APENAS PARA 2024)                   |
//+------------------------------------------------------------------+
input group "=== DETECTOR DE RANGE ==="
input bool     AutoDetectRange = true;       // Detectar automaticamente
input double   RangeThreshold = 0.0015;      // Limiar para considerar range
input int      RangeLookback = 50;           // Período de análise
input int      YearToForceRange = 2024;      // Forçar modo range neste ano

//+------------------------------------------------------------------+
//| VARIÁVEIS                                                      |
//+------------------------------------------------------------------+
int handleRSI, handleEMAFast, handleEMASlow, handleATR;
datetime lastTradeTime = 0;
int tradesToday = 0;
datetime lastDayChecked = 0;
bool isRangeMarket = false;
double currentRiskPercent;
double currentLotMultiplier = 1.0;
double currentSLMultiplier = 1.0;
double currentTPMultiplier = 1.0;
int currentMaxTrades;

//+------------------------------------------------------------------+
//| INICIALIZAÇÃO                                                  |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("=== FUNDEDNEXT HYBRID EA ===");
   Print("Estratégia: Original + Otimizações Range 2024");
   Print("Objetivo: Manter bons resultados 2020-2022, 2025");
   Print("          Aplicar otimização 1.56 PF apenas em range");
   
   handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleATR = iATR(_Symbol, _Period, 14);
   
   if(handleRSI == INVALID_HANDLE || handleEMAFast == INVALID_HANDLE || 
      handleEMASlow == INVALID_HANDLE)
   {
      Print("Erro ao criar indicadores!");
      return INIT_FAILED;
   }
   
   // Configurações padrão (original)
   currentRiskPercent = RiskPercent;
   currentMaxTrades = MaxTradesPerDay;
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| DETECTAR MERCADO EM RANGE                                      |
//+------------------------------------------------------------------+
bool DetectRangeMarket()
{
   if(!AutoDetectRange && !EnableRangeMode) return false;
   
   // Método 1: Forçar range para ano específico (2024)
   MqlDateTime currentTime;
   TimeCurrent(currentTime);
   if(currentTime.year == YearToForceRange)
   {
      Print("Forçando modo RANGE para ano ", YearToForceRange);
      isRangeMarket = true;
      return true;
   }
   
   // Método 2: Detecção por volatilidade
   double atrValues[];
   ArraySetAsSeries(atrValues, true);
   if(CopyBuffer(handleATR, 0, 0, RangeLookback, atrValues) >= RangeLookback)
   {
      double sumATR = 0;
      for(int i = 0; i < RangeLookback; i++) sumATR += atrValues[i];
      double avgATR = sumATR / RangeLookback;
      
      if(avgATR < RangeThreshold)
      {
         isRangeMarket = true;
         Print("Range detectado: ATR médio = ", avgATR);
         return true;
      }
   }
   
   // Método 3: Detecção por range de preço
   double highs[], lows[];
   ArraySetAsSeries(highs, true);
   ArraySetAsSeries(lows, true);
   
   if(CopyHigh(_Symbol, _Period, 0, RangeLookback, highs) == RangeLookback &&
      CopyLow(_Symbol, _Period, 0, RangeLookback, lows) == RangeLookback)
   {
      double maxHigh = highs[ArrayMaximum(highs)];
      double minLow = lows[ArrayMinimum(lows)];
      double range = maxHigh - minLow;
      
      if(range < RangeThreshold * 2)
      {
         isRangeMarket = true;
         Print("Range detectado: Range preço = ", range);
         return true;
      }
   }
   
   isRangeMarket = false;
   return false;
}

//+------------------------------------------------------------------+
//| APLICAR CONFIGURAÇÃO CONFORME MERCADO                          |
//+------------------------------------------------------------------+
void ApplyMarketConfig()
{
   if(isRangeMarket && EnableRangeMode)
   {
      // APLICAR CONFIGURAÇÕES OTIMIZADAS PARA RANGE (2024)
      currentRiskPercent = RangeRiskPercent;
      currentLotMultiplier = RangeLotMultiplier;
      currentSLMultiplier = RangeSLMultiplier;
      currentTPMultiplier = RangeTPMultiplier;
      currentMaxTrades = RangeMaxTrades;
      
      Print("=== MODO RANGE ATIVADO ===");
      Print("Risk: ", currentRiskPercent, "% | Lote: x", currentLotMultiplier);
      Print("SL: x", currentSLMultiplier, " | TP: x", currentTPMultiplier);
      Print("Max Trades: ", currentMaxTrades);
   }
   else
   {
      // MANTER CONFIGURAÇÃO ORIGINAL
      currentRiskPercent = RiskPercent;
      currentLotMultiplier = 1.0;
      currentSLMultiplier = 1.0;
      currentTPMultiplier = 1.0;
      currentMaxTrades = MaxTradesPerDay;
      
      Print("=== MODO ORIGINAL ATIVADO ===");
   }
}

//+------------------------------------------------------------------+
//| VERIFICAR POSIÇÃO ABERTA                                       |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionSelectByTicket(ticket))
         {
            if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
               return true;
         }
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| RESETAR DIA                                                    |
//+------------------------------------------------------------------+
void ResetDailyStats()
{
   datetime currentTime = TimeCurrent();
   MqlDateTime dt;
   TimeToStruct(currentTime, dt);
   
   if(lastDayChecked != dt.day)
   {
      lastDayChecked = dt.day;
      tradesToday = 0;
      Print("Novo dia - trades resetados");
   }
}

//+------------------------------------------------------------------+
//| VERIFICAR CONDIÇÕES                                            |
//+------------------------------------------------------------------+
bool CanTrade()
{
   ResetDailyStats();
   
   // Detectar tipo de mercado
   DetectRangeMarket();
   ApplyMarketConfig();
   
   // Verificar posição aberta
   if(HasOpenPosition()) return false;
   
   // Verificar limite diário
   if(tradesToday >= currentMaxTrades) 
   {
      Print("Limite diário: ", tradesToday, "/", currentMaxTrades);
      return false;
   }
   
   // Verificar spread
   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(spread > MaxSpread * 10) 
   {
      Print("Spread alto: ", spread);
      return false;
   }
   
   // Cooldown entre trades
   if(lastTradeTime > 0)
   {
      double minutes = (TimeCurrent() - lastTradeTime) / 60.0;
      double minCooldown = isRangeMarket ? 10.0 : 15.0;
      
      if(minutes < minCooldown) return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| OBTER VALORES DOS INDICADORES                                  |
//+------------------------------------------------------------------+
double GetRSI()
{
   double rsi[1];
   if(CopyBuffer(handleRSI, 0, 0, 1, rsi) == 1)
      return rsi[0];
   return 50.0;
}

double GetEMAFast()
{
   double ema[1];
   if(CopyBuffer(handleEMAFast, 0, 0, 1, ema) == 1)
      return ema[0];
   return 0;
}

double GetEMASlow()
{
   double ema[1];
   if(CopyBuffer(handleEMASlow, 0, 0, 1, ema) == 1)
      return ema[0];
   return 0;
}

//+------------------------------------------------------------------+
//| GERAR SINAL - ESTRATÉGIA ORIGINAL                             |
//+------------------------------------------------------------------+
int GenerateSignal()
{
   double rsi = GetRSI();
   double emaFast = GetEMAFast();
   double emaSlow = GetEMASlow();
   
   if(emaFast == 0 || emaSlow == 0) return -1;
   
   bool trendBullish = (emaFast > emaSlow);
   
   // ESTRATÉGIA ORIGINAL (NÃO MUDAR)
   if(rsi < RSIOversold && trendBullish)
   {
      Print("SINAL BUY ORIGINAL: RSI=", rsi, " EMA Fast=", emaFast, " Slow=", emaSlow);
      return ORDER_TYPE_BUY;
   }
   
   if(rsi > RSIOverbought && !trendBullish)
   {
      Print("SINAL SELL ORIGINAL: RSI=", rsi, " EMA Fast=", emaFast, " Slow=", emaSlow);
      return ORDER_TYPE_SELL;
   }
   
   return -1;
}

//+------------------------------------------------------------------+
//| CALCULAR LOTE CONFORME MERCADO                                |
//+------------------------------------------------------------------+
double CalculateLot()
{
   double lot = LotSize;
   
   if(UseDynamicLot)
   {
      double balance = AccountInfoDouble(ACCOUNT_EQUITY);
      double riskAmount = balance * (currentRiskPercent / 100.0);
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      
      double slPips = StopLossPips * currentSLMultiplier;
      
      double riskPerLot = slPips * point * tickValue / tickSize;
      if(riskPerLot > 0)
      {
         lot = riskAmount / riskPerLot;
         double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
         lot = MathFloor(lot / lotStep) * lotStep;
         
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
         lot = MathMax(minLot, MathMin(maxLot, lot));
      }
   }
   
   // Aplicar multiplicador conforme mercado
   lot *= currentLotMultiplier;
   
   if(isRangeMarket)
      Print("LOTE RANGE: ", lot, " (x", currentLotMultiplier, ")");
   
   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| EXECUTAR TRADE                                                 |
//+------------------------------------------------------------------+
bool ExecuteTrade(int type)
{
   double lot = CalculateLot();
   double price = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                                           : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double slPips = StopLossPips * currentSLMultiplier;
   double tpPips = TakeProfitPips * currentTPMultiplier;
   
   double sl = 0;
   double tp = 0;
   
   if(type == ORDER_TYPE_BUY)
   {
      sl = price - (slPips * point);
      tp = price + (tpPips * point);
   }
   else
   {
      sl = price + (slPips * point);
      tp = price - (tpPips * point);
   }
   
   // Garantir SL/TP válidos
   if(type == ORDER_TYPE_BUY)
   {
      if(sl >= price) sl = price - (10 * point);
      if(tp <= price) tp = price + (10 * point);
   }
   else
   {
      if(sl <= price) sl = price + (10 * point);
      if(tp >= price) tp = price - (10 * point);
   }
   
   MqlTradeRequest request;
   ZeroMemory(request);
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type = (type == ORDER_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   request.price = price;
   request.sl = sl;
   request.tp = tp;
   request.deviation = 10;
   request.magic = MagicNumber;
   request.comment = isRangeMarket ? "RANGE_MODE" : "ORIGINAL";
   request.type_filling = ORDER_FILLING_IOC;
   
   MqlTradeResult result;
   ZeroMemory(result);
   
   bool success = OrderSend(request, result);
   
   if(success && result.retcode == TRADE_RETCODE_DONE)
   {
      lastTradeTime = TimeCurrent();
      tradesToday++;
      
      string mode = isRangeMarket ? "[RANGE]" : "[ORIGINAL]";
      Print("Trade #", tradesToday, " ", mode, " ", (type == ORDER_TYPE_BUY ? "BUY" : "SELL"));
      Print("Lote: ", lot, " SL: ", slPips, "p (", sl, ") TP: ", tpPips, "p (", tp, ")");
      
      return true;
   }
   else
   {
      Print("Erro no trade: ", GetLastError());
      return false;
   }
}

//+------------------------------------------------------------------+
//| ON TICK                                                         |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!CanTrade()) return;
   
   int signal = GenerateSignal();
   if(signal != -1)
   {
      ExecuteTrade(signal);
   }
}

//+------------------------------------------------------------------+
//| DEINIT                                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if(handleRSI != INVALID_HANDLE) IndicatorRelease(handleRSI);
   if(handleEMAFast != INVALID_HANDLE) IndicatorRelease(handleEMAFast);
   if(handleEMASlow != INVALID_HANDLE) IndicatorRelease(handleEMASlow);
   if(handleATR != INVALID_HANDLE) IndicatorRelease(handleATR);
   
   Print("=== RESUMO FINAL ===");
   Print("Total trades: ", tradesToday);
   Print("Modo final: ", isRangeMarket ? "RANGE" : "ORIGINAL");
   Print("Config aplicada:");
   Print("  Risk: ", currentRiskPercent, "%");
   Print("  Lote Multiplier: x", currentLotMultiplier);
   Print("  SL Multiplier: x", currentSLMultiplier);
   Print("  TP Multiplier: x", currentTPMultiplier);
}
//+------------------------------------------------------------------+
