//+------------------------------------------------------------------+
//|                         HIGH PROFIT EA M15 EURUSD v3.3                      |
//|                 Estratégia Otimizada com Gestão de Risco         |
//+------------------------------------------------------------------+
#property copyright "High Profit EA v3.3"
#property version   "3.3"
#property description "EA otimizado com gestão de risco avançada M15 EURUSD"
#property strict

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO BÁSICA                                             |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO PRINCIPAL ==="
input int      MagicNumber = 777888;           // Número Mágico
input double   LotSize = 0.1;                  // Tamanho do Lote Fixo
input bool     UseDynamicLot = false;          // Usar Lote Dinâmico (% do saldo)
input double   RiskPercent = 2.0;              // Risco por Trade (% do saldo)
input double   MaxSpread = 15.0;               // Spread Máximo (pontos)

input group "=== LIMITES DIÁRIOS ==="
input bool     UseDailyLimit = false;          // Usar Limite Diário (DESATIVADO para teste)
input double   DailyProfitTarget = 5.0;        // Meta de Lucro Diário (%)
input double   DailyLossLimit = 3.0;           // Limite de Perda Diário (%)
input int      MaxTradesPerDay = 100;          // Máximo de Trades por Dia (aumentado para teste)
input int      MinMinutesBetweenTrades = 1;    // Minutos entre Trades (reduzido para teste)

//+------------------------------------------------------------------+
//| ESTRATÉGIA DE ENTRADA                                           |
//+------------------------------------------------------------------+
input group "=== FILTROS DE ENTRADA ==="
input bool     UseRSI = true;                  // Usar RSI
input int      RSIPeriod = 14;                 // Período do RSI
input double   RSIOverbought = 65.0;           // Nível Overbought (ajustado)
input double   RSIOversold = 35.0;             // Nível Oversold (ajustado)

input bool     UseEMA = true;                  // Usar EMA para tendência
input int      EMAFastPeriod = 50;              // EMA Rápida
input int      EMASlowPeriod = 200;             // EMA Lenta

input bool     UseMACD = false;                // Usar confirmação MACD (DESATIVADO)
input int      MACDFast = 12;                  // MACD Fast
input int      MACDSlow = 26;                  // MACD Slow
input int      MACDSignal = 9;                 // MACD Signal

input bool     UseVolatilityFilter = false;    // Filtro de Volatilidade (DESATIVADO para teste)
input int      ATRPeriod = 14;                 // Período ATR
input double   MinATRValue = 0.0005;           // ATR Mínimo (evita rangue)
input double   MaxATRValue = 0.0050;           // ATR Máximo (evita notícias)

//+------------------------------------------------------------------+
//| GESTÃO DE RISCO E SAÍDA                                         |
//+------------------------------------------------------------------+
// Enum para modos de risco
enum ENUM_RISK_MODE
{
   MODE_ATR,      // Baseado em ATR
   MODE_FIXED,    // Pontos fixos
   MODE_PERCENT   // % do preço
};

input group "=== GESTÃO DE RISCO ==="
input ENUM_RISK_MODE RiskMode = MODE_FIXED;    // Modo de Cálculo do SL (FIXADO para teste)
input double   StopLossATR = 1.5;              // Stop Loss (x ATR)
input double   TakeProfitATR = 2.5;            // Take Profit (x ATR)
input double   FixedStopLoss = 100.0;          // Stop Loss Fixo (pontos) - aumentado
input double   FixedTakeProfit = 150.0;        // Take Profit Fixo (pontos) - aumentado
input double   RiskRewardRatio = 1.5;          // Ratio Risco/Retorno

input group "=== SAÍDA AVANÇADA ==="
input bool     UseTrailingStop = false;        // Usar Trailing Stop (DESATIVADO para teste)
input double   TrailingStart = 20.0;           // Início Trailing (pontos)
input double   TrailingStep = 5.0;             // Passo Trailing (pontos)
input bool     UseBreakeven = false;           // Usar Breakeven (DESATIVADO para teste)
input double   BreakevenAt = 15.0;             // Ativar Breakeven (pontos)
input bool     UseTimeExit = false;            // Saída por Tempo
input int      MaxTradeHours = 24;             // Horas Máximas por Trade

//+------------------------------------------------------------------+
//| VARIÁVEIS GLOBAIS                                               |
//+------------------------------------------------------------------+
double dailyStartBalance = 0;
int tradesTodayCount = 0;
datetime lastTradeTime = 0;
datetime lastDailyReset = 0;
double totalProfitToday = 0;
double totalLossToday = 0;

// Handles dos indicadores
int handleRSI = INVALID_HANDLE;
int handleEMAFast = INVALID_HANDLE;
int handleEMASlow = INVALID_HANDLE;
int handleATR = INVALID_HANDLE;
int handleMACD = INVALID_HANDLE;

//+------------------------------------------------------------------+
//| INICIALIZAÇÃO DO EA                                             |
//+------------------------------------------------------------------+
int OnInit()
{
   // Limpar qualquer lixo anterior
   OnDeinit(REASON_INITFAILED);
   
   Print("========================================");
   Print("INICIANDO HIGH PROFIT EA v3.3");
   Print("Timeframe atual: ", EnumToString(_Period));
   Print("Símbolo: ", _Symbol);
   
   // Validar inputs
   if(!ValidateInputs())
   {
      Print("Erro: Validação de inputs falhou!");
      return INIT_PARAMETERS_INCORRECT;
   }
   
   // Inicializar contadores
   InitializeDailyStats();
   
   // Criar indicadores necessários
   if(!CreateIndicators())
   {
      Print("Erro: Falha ao criar indicadores!");
      return INIT_FAILED;
   }
   
   // Configurar timer para updates
   EventSetTimer(1);
   
   // Testar indicadores
   TestIndicators();
   
   Print("EA INICIALIZADO COM SUCESSO");
   Print("========================================");
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| TESTAR INDICADORES                                              |
//+------------------------------------------------------------------+
void TestIndicators()
{
   Print("Testando indicadores...");
   
   double rsi = GetRSIValue();
   double emaFast = GetEMAFastValue();
   double emaSlow = GetEMASlowValue();
   double atr = GetATRValue();
   
   Print("RSI: ", rsi);
   Print("EMA Fast: ", emaFast);
   Print("EMA Slow: ", emaSlow);
   Print("ATR: ", atr);
   Print("Bid: ", SymbolInfoDouble(_Symbol, SYMBOL_BID));
   Print("Ask: ", SymbolInfoDouble(_Symbol, SYMBOL_ASK));
   
   // Testar sinal
   int signal = GenerateEntrySignal();
   Print("Sinal gerado: ", signal);
}

//+------------------------------------------------------------------+
//| VALIDAÇÃO DE INPUTS                                             |
//+------------------------------------------------------------------+
bool ValidateInputs()
{
   if(LotSize <= 0 && !UseDynamicLot)
   {
      Print("Erro: LotSize deve ser maior que 0!");
      return false;
   }
   
   if(UseDynamicLot && (RiskPercent <= 0 || RiskPercent > 10))
   {
      Print("Erro: RiskPercent deve estar entre 0.1 e 10!");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| INICIALIZAR ESTATÍSTICAS DIÁRIAS                                |
//+------------------------------------------------------------------+
void InitializeDailyStats()
{
   MqlDateTime today, lastReset;
   
   TimeCurrent(today);
   TimeToStruct(lastDailyReset, lastReset);
   
   // Reset se for novo dia
   if(today.day != lastReset.day || today.mon != lastReset.mon || today.year != lastReset.year)
   {
      dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      tradesTodayCount = 0;
      totalProfitToday = 0;
      totalLossToday = 0;
      lastDailyReset = TimeCurrent();
      
      Print("Novo dia iniciado. Saldo: ", dailyStartBalance);
   }
   else
   {
      dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      Print("Dia continuado. Saldo: ", dailyStartBalance);
   }
}

//+------------------------------------------------------------------+
//| CRIAR INDICADORES                                               |
//+------------------------------------------------------------------+
bool CreateIndicators()
{
   Print("Criando indicadores...");
   
   // RSI
   if(UseRSI)
   {
      handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
      if(handleRSI == INVALID_HANDLE)
      {
         Print("Falha ao criar RSI!");
         return false;
      }
      Print("RSI criado com sucesso");
   }
   
   // EMA Fast
   if(UseEMA)
   {
      handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
      handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
      
      if(handleEMAFast == INVALID_HANDLE || handleEMASlow == INVALID_HANDLE)
      {
         Print("Falha ao criar EMAs!");
         return false;
      }
      Print("EMAs criadas com sucesso");
   }
   
   // ATR
   if(UseVolatilityFilter)
   {
      handleATR = iATR(_Symbol, _Period, ATRPeriod);
      if(handleATR == INVALID_HANDLE)
      {
         Print("Falha ao criar ATR!");
         return false;
      }
      Print("ATR criado com sucesso");
   }
   
   // MACD
   if(UseMACD)
   {
      handleMACD = iMACD(_Symbol, _Period, MACDFast, MACDSlow, MACDSignal, PRICE_CLOSE);
      if(handleMACD == INVALID_HANDLE)
      {
         Print("Falha ao criar MACD!");
         return false;
      }
      Print("MACD criado com sucesso");
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| FINALIZAÇÃO DO EA                                               |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Liberar indicadores
   if(handleRSI != INVALID_HANDLE)
   {
      IndicatorRelease(handleRSI);
      handleRSI = INVALID_HANDLE;
   }
   
   if(handleEMAFast != INVALID_HANDLE)
   {
      IndicatorRelease(handleEMAFast);
      handleEMAFast = INVALID_HANDLE;
   }
   
   if(handleEMASlow != INVALID_HANDLE)
   {
      IndicatorRelease(handleEMASlow);
      handleEMASlow = INVALID_HANDLE;
   }
   
   if(handleATR != INVALID_HANDLE)
   {
      IndicatorRelease(handleATR);
      handleATR = INVALID_HANDLE;
   }
   
   if(handleMACD != INVALID_HANDLE)
   {
      IndicatorRelease(handleMACD);
      handleMACD = INVALID_HANDLE;
   }
   
   // Parar timer
   EventKillTimer();
   
   // Relatório final
   Print("========================================");
   Print("HIGH PROFIT EA FINALIZADO");
   Print("Motivo: ", GetDeinitReasonText(reason));
   Print("Trades Hoje: ", tradesTodayCount);
   Print("Lucro Total: ", totalProfitToday);
   Print("Perda Total: ", totalLossToday);
   Print("Saldo Final: ", AccountInfoDouble(ACCOUNT_BALANCE));
   Print("========================================");
}

//+------------------------------------------------------------------+
//| TEXTO MOTIVO DEINIT                                             |
//+------------------------------------------------------------------+
string GetDeinitReasonText(int reason)
{
   switch(reason)
   {
      case REASON_ACCOUNT:
         return "Conta alterada";
      case REASON_CHARTCHANGE:
         return "Gráfico alterado";
      case REASON_CHARTCLOSE:
         return "Gráfico fechado";
      case REASON_PARAMETERS:
         return "Parâmetros alterados";
      case REASON_RECOMPILE:
         return "Recompilação";
      case REASON_REMOVE:
         return "EA removido";
      case REASON_TEMPLATE:
         return "Template alterado";
      case REASON_INITFAILED:
         return "Inicialização falhou";
      default:
         return "Desconhecido";
   }
}

//+------------------------------------------------------------------+
//| VERIFICAÇÕES DE SEGURANÇA                                       |
//+------------------------------------------------------------------+
bool CheckTradingConditions()
{
   // DEBUG: Mostrar status atual
   static int tickCount = 0;
   tickCount++;
   
   if(tickCount % 100 == 0) // A cada 100 ticks
   {
      Print("Tick #", tickCount, " - Verificando condições...");
      Print("Trades hoje: ", tradesTodayCount, "/", MaxTradesPerDay);
      Print("Último trade: ", lastTradeTime);
   }
   
   // 1. Verificar se é novo dia
   CheckDailyReset();
   
   // 2. Verificar horário de mercado
   if(!CheckTradingHours())
   {
      return false;
   }
   
   // 3. Verificar limite diário
   if(!CheckDailyLimits())
   {
      return false;
   }
   
   // 4. Verificar spread
   if(!CheckCurrentSpread())
   {
      return false;
   }
   
   // 5. Verificar tempo entre trades
   if(!CheckTimeGap())
   {
      return false;
   }
   
   // 6. Verificar se já tem posição aberta
   if(HasOpenPosition())
   {
      if(tickCount % 100 == 0)
         Print("Já existe posição aberta - aguardando");
      return false;
   }
   
   // 7. Verificar volatilidade do mercado
   if(!CheckMarketVolatility())
   {
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| VERIFICAR RESET DIÁRIO                                          |
//+------------------------------------------------------------------+
void CheckDailyReset()
{
   MqlDateTime now, lastReset;
   
   TimeCurrent(now);
   TimeToStruct(lastDailyReset, lastReset);
   
   if(now.day != lastReset.day || now.mon != lastReset.mon || now.year != lastReset.year)
   {
      dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      tradesTodayCount = 0;
      totalProfitToday = 0;
      totalLossToday = 0;
      lastDailyReset = TimeCurrent();
      
      Print("========================================");
      Print("RESET DIÁRIO REALIZADO");
      Print("Data: ", TimeToString(TimeCurrent(), TIME_DATE));
      Print("Novo Saldo Base: ", dailyStartBalance);
      Print("========================================");
   }
}

//+------------------------------------------------------------------+
//| VERIFICAR HORÁRIO DE TRADING                                    |
//+------------------------------------------------------------------+
bool CheckTradingHours()
{
   MqlDateTime now;
   TimeCurrent(now);
   
   // Para teste, permitir trading em qualquer horário
   // Remova este return true para ativar a verificação
   return true;
   
   /*
   // Evitar trading perto de notícias importantes
   if(now.day_of_week == 5 && now.hour >= 22) return false;
   if(now.day_of_week == 6) return false;
   if(now.day_of_week == 0 && now.hour < 22) return false;
   
   return true;
   */
}

//+------------------------------------------------------------------+
//| VERIFICAR LIMITES DIÁRIOS                                       |
//+------------------------------------------------------------------+
bool CheckDailyLimits()
{
   if(!UseDailyLimit) return true;
   
   double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double dailyProfitPercent = ((currentBalance - dailyStartBalance) / dailyStartBalance) * 100.0;
   
   // Verificar meta de lucro
   if(dailyProfitPercent >= DailyProfitTarget)
   {
      Print("Meta diária atingida! Lucro: ", DoubleToString(dailyProfitPercent, 2), "%");
      return false;
   }
   
   // Verificar limite de perda
   if(dailyProfitPercent <= -DailyLossLimit)
   {
      Print("Limite de perda diária! Prejuízo: ", DoubleToString(dailyProfitPercent, 2), "%");
      return false;
   }
   
   // Verificar máximo de trades
   if(tradesTodayCount >= MaxTradesPerDay)
   {
      Print("Máximo de trades diários atingido: ", tradesTodayCount);
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| VERIFICAR SPREAD ATUAL                                          |
//+------------------------------------------------------------------+
bool CheckCurrentSpread()
{
   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   double spreadInPoints = (double)spread * Point();
   
   // Converter MaxSpread de pontos para valor real
   double maxSpreadValue = MaxSpread * Point();
   
   if(spreadInPoints > maxSpreadValue)
   {
      Print("Spread atual: ", spreadInPoints, " > máximo: ", maxSpreadValue);
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| VERIFICAR INTERVALO DE TEMPO                                    |
//+------------------------------------------------------------------+
bool CheckTimeGap()
{
   if(lastTradeTime == 0) return true;
   
   datetime now = TimeCurrent();
   double minutesPassed = (double)(now - lastTradeTime) / 60.0;
   
   if(minutesPassed < MinMinutesBetweenTrades)
   {
      if(minutesPassed < 1) // Só mostrar a cada minuto
         return false;
      
      double waitTime = MinMinutesBetweenTrades - minutesPassed;
      Print("Aguardando ", DoubleToString(waitTime, 0), " minutos para próximo trade");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| VERIFICAR POSIÇÃO ABERTA                                        |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   int totalPositions = PositionsTotal();
   
   for(int i = totalPositions - 1; i >= 0; i--)
   {
      if(PositionGetTicket(i))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            return true;
         }
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| VERIFICAR VOLATILIDADE                                          |
//+------------------------------------------------------------------+
bool CheckMarketVolatility()
{
   if(!UseVolatilityFilter) return true;
   
   double atrValue = GetATRValue();
   
   if(atrValue < MinATRValue)
   {
      Print("Mercado muito parado. ATR: ", atrValue, " < mínimo: ", MinATRValue);
      return false;
   }
   
   if(atrValue > MaxATRValue)
   {
      Print("Mercado muito volátil. ATR: ", atrValue, " > máximo: ", MaxATRValue);
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| CÁLCULO DE LOTE DINÂMICO                                        |
//+------------------------------------------------------------------+
double CalculateLotSize()
{
   if(!UseDynamicLot) 
   {
      double lot = NormalizeDouble(LotSize, 2);
      Print("Lote fixo: ", lot);
      return lot;
   }
   
   double accountBalance = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskAmount = accountBalance * (RiskPercent / 100.0);
   
   // Calcular valor do pip
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // Calcular stop loss em pontos
   double stopPoints = FixedStopLoss; // Usando valor fixo para simplificar
   
   // Calcular lote baseado no risco
   double riskLot = riskAmount / (stopPoints * tickValue * (Point() / tickSize));
   
   // Normalizar para os passos de lote do símbolo
   riskLot = MathFloor(riskLot / lotStep) * lotStep;
   
   // Limites de lote
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   
   riskLot = MathMax(riskLot, minLot);
   riskLot = MathMin(riskLot, maxLot);
   
   Print("Lote dinâmico: ", riskLot);
   return NormalizeDouble(riskLot, 2);
}

//+------------------------------------------------------------------+
//| OBTER VALORES DOS INDICADORES                                   |
//+------------------------------------------------------------------+
double GetRSIValue()
{
   if(!UseRSI || handleRSI == INVALID_HANDLE) 
   {
      Print("RSI não disponível");
      return 50.0;
   }
   
   double rsi[1];
   if(CopyBuffer(handleRSI, 0, 0, 1, rsi) == 1)
      return NormalizeDouble(rsi[0], 2);
   
   Print("Erro ao copiar RSI");
   return 50.0;
}

double GetEMAFastValue()
{
   if(!UseEMA || handleEMAFast == INVALID_HANDLE) 
   {
      Print("EMA Fast não disponível");
      return 0;
   }
   
   double ema[1];
   if(CopyBuffer(handleEMAFast, 0, 0, 1, ema) == 1)
      return ema[0];
   
   Print("Erro ao copiar EMA Fast");
   return 0;
}

double GetEMASlowValue()
{
   if(!UseEMA || handleEMASlow == INVALID_HANDLE) 
   {
      Print("EMA Slow não disponível");
      return 0;
   }
   
   double ema[1];
   if(CopyBuffer(handleEMASlow, 0, 0, 1, ema) == 1)
      return ema[0];
   
   Print("Erro ao copiar EMA Slow");
   return 0;
}

double GetATRValue()
{
   if(!UseVolatilityFilter || handleATR == INVALID_HANDLE) 
   {
      return 0.001;
   }
   
   double atr[1];
   if(CopyBuffer(handleATR, 0, 0, 1, atr) == 1)
      return atr[0];
   
   return 0.001;
}

bool GetMACDSignal()
{
   if(!UseMACD || handleMACD == INVALID_HANDLE) return true;
   
   double macdMain[1], macdSignal[1];
   if(CopyBuffer(handleMACD, MAIN_LINE, 0, 1, macdMain) != 1) return true;
   if(CopyBuffer(handleMACD, SIGNAL_LINE, 0, 1, macdSignal) != 1) return true;
   
   return (macdMain[0] > macdSignal[0]);
}

//+------------------------------------------------------------------+
//| GERAR SINAL DE ENTRADA                                          |
//+------------------------------------------------------------------+
int GenerateEntrySignal()
{
   // Obter valores dos indicadores
   double rsi = GetRSIValue();
   double emaFast = GetEMAFastValue();
   double emaSlow = GetEMASlowValue();
   double atr = GetATRValue();
   bool macdBullish = GetMACDSignal();
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   // DEBUG: Mostrar valores
   static int signalCount = 0;
   signalCount++;
   
   if(signalCount % 50 == 0) // A cada 50 chamadas
   {
      Print("=== DEBUG SINAL ===");
      Print("RSI: ", rsi, " | Oversold: ", RSIOversold, " | Overbought: ", RSIOverbought);
      Print("EMA Fast: ", emaFast, " | EMA Slow: ", emaSlow);
      Print("Preço Atual: ", currentPrice);
      Print("===================");
   }
   
   // Verificar se valores são válidos
   if(emaFast == 0 || emaSlow == 0 || rsi == 50.0)
   {
      Print("Indicadores não carregados corretamente");
      return -1;
   }
   
   // Verificar confirmação de tendência com EMA
   bool emaBullish = (emaFast > emaSlow);
   bool emaConfirmed = !UseEMA || (UseEMA && emaBullish);
   
   // Verificar confirmação MACD se ativado
   bool macdConfirmed = !UseMACD || (UseMACD && macdBullish);
   
   // SINAL DE COMPRA
   if(rsi < RSIOversold)
   {
      if(emaConfirmed || !UseEMA) // Se EMA confirmar ou EMA não estiver ativo
      {
         if(macdConfirmed || !UseMACD) // Se MACD confirmar ou MACD não estiver ativo
         {
            Print("=== SINAL FORTE DE COMPRA ===");
            Print("RSI: ", rsi, " (oversold)");
            Print("EMA Fast: ", emaFast, " > EMA Slow: ", emaSlow, " ? ", emaBullish);
            Print("Preço: ", currentPrice, " | EMA Slow: ", emaSlow);
            return ORDER_TYPE_BUY;
         }
      }
   }
   
   // SINAL DE VENDA
   if(rsi > RSIOverbought)
   {
      if(!emaConfirmed || !UseEMA) // Se EMA bearish ou EMA não ativo
      {
         if(!macdConfirmed || !UseMACD) // Se MACD bearish ou MACD não ativo
         {
            Print("=== SINAL FORTE DE VENDA ===");
            Print("RSI: ", rsi, " (overbought)");
            Print("EMA Fast: ", emaFast, " > EMA Slow: ", emaSlow, " ? ", emaBullish);
            Print("Preço: ", currentPrice, " | EMA Slow: ", emaSlow);
            return ORDER_TYPE_SELL;
         }
      }
   }
   
   return -1; // Sem sinal
}

//+------------------------------------------------------------------+
//| CALCULAR STOP LOSS E TAKE PROFIT                                |
//+------------------------------------------------------------------+
void CalculateSLTP(int signal, double &sl, double &tp)
{
   double entryPrice = (signal == ORDER_TYPE_BUY) ? 
                      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                      SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   double atrValue = GetATRValue();
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   if(RiskMode == MODE_ATR)
   {
      if(signal == ORDER_TYPE_BUY)
      {
         sl = entryPrice - (atrValue * StopLossATR);
         tp = entryPrice + (atrValue * TakeProfitATR);
      }
      else // SELL
      {
         sl = entryPrice + (atrValue * StopLossATR);
         tp = entryPrice - (atrValue * TakeProfitATR);
      }
   }
   else if(RiskMode == MODE_FIXED)
   {
      if(signal == ORDER_TYPE_BUY)
      {
         sl = entryPrice - (FixedStopLoss * point);
         tp = entryPrice + (FixedTakeProfit * point);
      }
      else // SELL
      {
         sl = entryPrice + (FixedStopLoss * point);
         tp = entryPrice - (FixedTakeProfit * point);
      }
   }
   
   // Ajustar TP baseado no Risk/Reward Ratio
   if(RiskRewardRatio > 0)
   {
      double risk = MathAbs(entryPrice - sl);
      tp = (signal == ORDER_TYPE_BUY) ? 
           entryPrice + (risk * RiskRewardRatio) : 
           entryPrice - (risk * RiskRewardRatio);
   }
   
   // Normalizar preços
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   sl = NormalizeDouble(sl, digits);
   tp = NormalizeDouble(tp, digits);
   
   Print("SL calculado: ", sl, " | TP: ", tp);
}

//+------------------------------------------------------------------+
//| EXECUTAR TRADE                                                  |
//+------------------------------------------------------------------+
bool ExecuteTrade(int signal)
{
   if(signal != ORDER_TYPE_BUY && signal != ORDER_TYPE_SELL) 
   {
      Print("Sinal inválido para trade");
      return false;
   }
   
   // Calcular tamanho do lote
   double tradeLot = CalculateLotSize();
   
   // Verificar se lote é válido
   if(tradeLot <= 0)
   {
      Print("Lote inválido: ", tradeLot);
      return false;
   }
   
   // Calcular SL e TP
   double sl = 0, tp = 0;
   CalculateSLTP(signal, sl, tp);
   
   // Preparar ordem
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = tradeLot;
   request.type = (ENUM_ORDER_TYPE)signal;
   request.price = (signal == ORDER_TYPE_BUY) ? 
                   SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                   SymbolInfoDouble(_Symbol, SYMBOL_BID);
   request.sl = sl;
   request.tp = tp;
   request.deviation = 50; // Aumentado para evitar requotes
   request.magic = MagicNumber;
   request.comment = "HPEA v3.3";
   request.type_filling = ORDER_FILLING_IOC;
   request.type_time = ORDER_TIME_GTC;
   
   // DEBUG
   Print("Enviando ordem...");
   Print("Símbolo: ", request.symbol);
   Print("Volume: ", request.volume);
   Print("Preço: ", request.price);
   Print("SL: ", request.sl);
   Print("TP: ", request.tp);
   
   // Enviar ordem
   bool sent = OrderSend(request, result);
   
   if(sent)
   {
      Print("Ordem enviada. Retcode: ", result.retcode);
      
      if(result.retcode == TRADE_RETCODE_DONE)
      {
         lastTradeTime = TimeCurrent();
         tradesTodayCount++;
         
         Print("========================================");
         Print("TRADE EXECUTADO COM SUCESSO!");
         Print("Ticket: ", result.order);
         Print("Direção: ", (signal == ORDER_TYPE_BUY) ? "COMPRA" : "VENDA");
         Print("Volume: ", tradeLot);
         Print("Preço: ", request.price);
         Print("SL: ", sl, " | TP: ", tp);
         Print("Trades hoje: ", tradesTodayCount);
         Print("========================================");
         
         return true;
      }
      else
      {
         Print("Ordem rejeitada. Código: ", result.retcode);
         Print("Comentário: ", result.comment);
      }
   }
   else
   {
      Print("ERRO ao enviar ordem: ", GetLastError());
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| GERENCIAR POSIÇÕES ABERTAS                                      |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
   int totalPositions = PositionsTotal();
   
   if(totalPositions > 0)
   {
      Print("Gerenciando ", totalPositions, " posições abertas");
   }
   
   for(int i = totalPositions - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      double currentPrice = (posType == POSITION_TYPE_BUY) ? 
                           SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                           SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      // Calcular distância do ponto de entrada
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      double distancePoints = MathAbs(currentPrice - entryPrice) / point;
      
      // GERENCIAR BREAKEVEN
      if(UseBreakeven && currentSL != entryPrice)
      {
         if(distancePoints >= BreakevenAt)
         {
            double newSL = entryPrice;
            
            // Ajustar SL para breakeven + spread
            if(posType == POSITION_TYPE_BUY)
               newSL = entryPrice + (5 * point);
            else
               newSL = entryPrice - (5 * point);
            
            MqlTradeRequest request;
            MqlTradeResult result;
            ZeroMemory(request);
            ZeroMemory(result);
            
            request.action = TRADE_ACTION_SLTP;
            request.position = ticket;
            request.sl = newSL;
            request.tp = currentTP;
            
            if(OrderSend(request, result))
            {
               Print("Breakeven ativado! Ticket: ", ticket);
               Print("Novo SL: ", newSL);
            }
         }
      }
      
      // GERENCIAR TRAILING STOP
      if(UseTrailingStop)
      {
         double newSL = currentSL;
         bool updateNeeded = false;
         
         if(posType == POSITION_TYPE_BUY)
         {
            if(distancePoints >= TrailingStart)
            {
               double trailLevel = entryPrice + ((distancePoints - TrailingStep) * point);
               if(trailLevel > currentSL && trailLevel < currentPrice - (10 * point))
               {
                  newSL = trailLevel;
                  updateNeeded = true;
               }
            }
         }
         else if(posType == POSITION_TYPE_SELL)
         {
            if(distancePoints >= TrailingStart)
            {
               double trailLevel = entryPrice - ((distancePoints - TrailingStep) * point);
               if(trailLevel < currentSL && trailLevel > currentPrice + (10 * point))
               {
                  newSL = trailLevel;
                  updateNeeded = true;
               }
            }
         }
         
         if(updateNeeded)
         {
            MqlTradeRequest request;
            MqlTradeResult result;
            ZeroMemory(request);
            ZeroMemory(result);
            
            request.action = TRADE_ACTION_SLTP;
            request.position = ticket;
            request.sl = newSL;
            request.tp = currentTP;
            
            if(OrderSend(request, result))
            {
               Print("Trailing atualizado! Ticket: ", ticket);
               Print("Novo SL: ", newSL);
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| ATUALIZAR ESTATÍSTICAS                                          |
//+------------------------------------------------------------------+
void UpdateStatistics()
{
   static datetime lastUpdate = 0;
   
   if(TimeCurrent() - lastUpdate < 60) // A cada 1 minuto
      return;
   
   double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double dailyProfitPercent = ((currentBalance - dailyStartBalance) / dailyStartBalance) * 100.0;
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double drawdownPercent = ((currentBalance - currentEquity) / currentBalance) * 100.0;
   
   Print("=== ESTATÍSTICAS ===");
   Print("Saldo: ", currentBalance);
   Print("Equity: ", currentEquity);
   Print("Trades Hoje: ", tradesTodayCount, "/", MaxTradesPerDay);
   Print("Lucro Diário: ", DoubleToString(dailyProfitPercent, 2), "%");
   Print("Drawdown: ", DoubleToString(drawdownPercent, 2), "%");
   Print("====================");
   
   lastUpdate = TimeCurrent();
}

//+------------------------------------------------------------------+
//| EVENTO ON TICK                                                  |
//+------------------------------------------------------------------+
void OnTick()
{
   // 1. Atualizar estatísticas
   UpdateStatistics();
   
   // 2. Verificar condições de trading
   if(!CheckTradingConditions()) 
   {
      return;
   }
   
   // 3. Gerenciar posições abertas
   ManageOpenPositions();
   
   // 4. Gerar sinal de entrada
   int signal = GenerateEntrySignal();
   
   // 5. Executar trade se houver sinal válido
   if(signal != -1)
   {
      Print("SINAL DETECTADO! Executando trade...");
      ExecuteTrade(signal);
   }
}

//+------------------------------------------------------------------+
//| EVENTO ON TIMER                                                 |
//+------------------------------------------------------------------+
void OnTimer()
{
   // Verificar conexão
   if(!TerminalInfoInteger(TERMINAL_CONNECTED))
   {
      Print("ALERTA: Terminal desconectado!");
      return;
   }
}
//+------------------------------------------------------------------+
