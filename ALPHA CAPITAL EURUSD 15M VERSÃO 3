//+------------------------------------------------------------------+
//|                 FUNDEDNEXT EA - 2024 SURVIVAL MODE             |
//|       Solução CIRÚRGICA para o problema específico de 2024     |
//+------------------------------------------------------------------+
#property copyright "2024 Survival Mode"
#property version   "13.0"
#property description "Correção específica para condições range extremas de 2024"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO PRINCIPAL                                          |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO PRINCIPAL ==="
input int      MagicNumber = 777888;
input double   LotSize = 0.5;
input bool     UseDynamicLot = true;
input double   RiskPercent = 0.5;
input double   MaxSpread = 10.0;

//+------------------------------------------------------------------+
//| ESTRATÉGIA ORIGINAL - NÃO MUDAR                                |
//+------------------------------------------------------------------+
input group "=== ESTRATÉGIA ORIGINAL ==="
input int      RSIPeriod = 14;
input double   RSIOverbought = 68.0;
input double   RSIOversold = 33.0;
input int      EMAFastPeriod = 16;
input int      EMASlowPeriod = 200;

//+------------------------------------------------------------------+
//| RISCO                                                           |
//+------------------------------------------------------------------+
input group "=== RISCO ==="
input double   StopLossPips = 100.0;
input double   TakeProfitPips = 150.0;
input int      MaxTradesPerDay = 5;

//+------------------------------------------------------------------+
//| MODO DE SOBREVIVÊNCIA 2024 - ATIVAR APENAS EM 2024            |
//+------------------------------------------------------------------+
input group "=== MODO 2024 (ativar apenas para 2024) ==="
input bool     Enable2024SurvivalMode = true;     // ATIVAR NO BACKTEST 2024
input double   LotMultiplier2024 = 0.7;          // REDUZIR lote em 30%
input double   SLMultiplier2024 = 0.8;           // SL 20% mais apertado
input double   TPMultiplier2024 = 0.6;           // TP 40% menor (lucro rápido)
input bool     UsePartialCloses2024 = true;      // Fechamentos parciais
input double   Close50at = 50.0;                 // Fechar 50% aos 50 pips
input double   Close30at = 100.0;                // Fechar 30% aos 100 pips
input bool     UseBreakeven2024 = true;          // Mover para breakeven
input double   BreakevenTrigger = 30.0;          // Acionar aos 30 pips
input bool     UseTimeFilter2024 = true;         // Filtrar horários ruins
input string   AvoidHoursStart = "13:00";        // Evitar horário americano
input string   AvoidHoursEnd = "17:00";
input int      MaxDailyLoss2024 = 3;             // Máx trades perdedores/dia
input double   MaxDailyDrawdownPercent = 2.0;    // Máx drawdown diário

//+------------------------------------------------------------------+
//| DETECTOR DE 2024 - SIMPLES E EFETIVO                          |
//+------------------------------------------------------------------+
input group "=== DETECTOR CONDIÇÕES 2024 ==="
input bool     AutoDetect2024 = true;            // Detectar automaticamente
input double   VolatilityThreshold = 0.00025;    // Volatilidade muito baixa
input int      LookbackBars = 40;                // Velas para análise

//+------------------------------------------------------------------+
//| VARIÁVEIS                                                      |
//+------------------------------------------------------------------+
int handleRSI, handleEMAFast, handleEMASlow, handleATR;
datetime lastTradeTime = 0;
int tradesToday = 0;
datetime lastDayChecked = 0;
bool is2024Conditions = false;
int losingTradesToday = 0;
double dailyEquityHigh = 0;
double dailyEquityLow = 0;

//+------------------------------------------------------------------+
//| INICIALIZAÇÃO                                                  |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("=== 2024 SURVIVAL MODE EA ===");
   Print("OBJETIVO: Transformar PF 0.92 (-9.3K) em lucrativo");
   Print("ESTRATÉGIA: Manter entradas, melhorar gerenciamento");
   
   handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleATR = iATR(_Symbol, _Period, 14);
   
   if(handleRSI == INVALID_HANDLE || handleEMAFast == INVALID_HANDLE || 
      handleEMASlow == INVALID_HANDLE)
      return INIT_FAILED;
   
   dailyEquityHigh = AccountInfoDouble(ACCOUNT_EQUITY);
   dailyEquityLow = dailyEquityHigh;
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| DETECTAR CONDIÇÕES TIPO 2024                                   |
//+------------------------------------------------------------------+
bool Detect2024Market()
{
   if(!AutoDetect2024) return false;
   
   // Método 1: Verificar volatilidade (ATR)
   double atrValues[];
   ArraySetAsSeries(atrValues, true);
   if(CopyBuffer(handleATR, 0, 0, LookbackBars, atrValues) >= LookbackBars)
   {
      double sumATR = 0;
      int count = 0;
      for(int i = 0; i < LookbackBars; i++)
      {
         if(atrValues[i] > 0)
         {
            sumATR += atrValues[i];
            count++;
         }
      }
      
      if(count > 0)
      {
         double avgATR = sumATR / count;
         if(avgATR < VolatilityThreshold)
         {
            is2024Conditions = true;
            Print("Condições 2024 detectadas: ATR muito baixo = ", avgATR);
            return true;
         }
      }
   }
   
   // Método 2: Verificar range price
   double highs[], lows[];
   ArraySetAsSeries(highs, true);
   ArraySetAsSeries(lows, true);
   
   if(CopyHigh(_Symbol, _Period, 0, LookbackBars, highs) == LookbackBars &&
      CopyLow(_Symbol, _Period, 0, LookbackBars, lows) == LookbackBars)
   {
      double maxHigh = highs[ArrayMaximum(highs)];
      double minLow = lows[ArrayMinimum(lows)];
      double range = maxHigh - minLow;
      
      if(range < (VolatilityThreshold * 15)) // Range muito apertado
      {
         is2024Conditions = true;
         Print("Condições 2024 detectadas: Range apertado = ", range);
         return true;
      }
   }
   
   is2024Conditions = false;
   return false;
}

//+------------------------------------------------------------------+
//| VERIFICAR HORÁRIO PARA EVITAR                                 |
//+------------------------------------------------------------------+
bool IsBadTradingTime()
{
   if(!UseTimeFilter2024 || !is2024Conditions) return false;
   
   datetime current = TimeCurrent();
   MqlDateTime currTime;
   TimeToStruct(current, currTime);
   
   MqlDateTime avoidStart, avoidEnd;
   TimeToStruct(StringToTime(AvoidHoursStart), avoidStart);
   TimeToStruct(StringToTime(AvoidHoursEnd), avoidEnd);
   
   int currentMinutes = currTime.hour * 60 + currTime.min;
   int avoidStartMinutes = avoidStart.hour * 60 + avoidStart.min;
   int avoidEndMinutes = avoidEnd.hour * 60 + avoidEnd.min;
   
   // Evitar horário de abertura americana (alta volatilidade em range)
   return (currentMinutes >= avoidStartMinutes && currentMinutes <= avoidEndMinutes);
}

//+------------------------------------------------------------------+
//| VERIFICAR DRAWDOWN DIÁRIO                                      |
//+------------------------------------------------------------------+
bool CheckDailyDrawdown()
{
   if(!is2024Conditions) return true;
   
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   // Atualizar highs/lows do dia
   if(currentEquity > dailyEquityHigh) dailyEquityHigh = currentEquity;
   if(currentEquity < dailyEquityLow) dailyEquityLow = currentEquity;
   
   // Calcular drawdown do dia
   double drawdownPercent = 0;
   if(dailyEquityHigh > 0)
   {
      drawdownPercent = ((dailyEquityHigh - currentEquity) / dailyEquityHigh) * 100.0;
   }
   
   if(drawdownPercent > MaxDailyDrawdownPercent)
   {
      Print("STOP: Drawdown diário excedido: ", drawdownPercent, "%");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| VERIFICAR PERDAS CONSECUTIVAS                                 |
//+------------------------------------------------------------------+
bool CheckConsecutiveLosses()
{
   if(!is2024Conditions) return true;
   
   if(losingTradesToday >= MaxDailyLoss2024)
   {
      Print("STOP: Máximo de trades perdedores atingido: ", losingTradesToday);
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| VERIFICAR POSIÇÃO ABERTA                                       |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| RESETAR DIA                                                    |
//+------------------------------------------------------------------+
void ResetDailyStats()
{
   datetime currentTime = TimeCurrent();
   MqlDateTime dt;
   TimeToStruct(currentTime, dt);
   
   if(lastDayChecked != dt.day)
   {
      lastDayChecked = dt.day;
      tradesToday = 0;
      losingTradesToday = 0;
      dailyEquityHigh = AccountInfoDouble(ACCOUNT_EQUITY);
      dailyEquityLow = dailyEquityHigh;
      Print("Estatísticas do dia resetadas");
   }
}

//+------------------------------------------------------------------+
//| VERIFICAR CONDIÇÕES                                            |
//+------------------------------------------------------------------+
bool CanTrade()
{
   ResetDailyStats();
   
   // Detectar condições 2024
   if(AutoDetect2024)
      Detect2024Market();
   
   // Verificar posição aberta
   if(HasOpenPosition()) return false;
   
   // Verificar limite diário
   if(tradesToday >= MaxTradesPerDay) 
   {
      Print("Limite diário atingido: ", tradesToday, "/", MaxTradesPerDay);
      return false;
   }
   
   // Verificações específicas para 2024
   if(is2024Conditions && Enable2024SurvivalMode)
   {
      // 1. Evitar horários ruins
      if(IsBadTradingTime())
      {
         Print("Horário evitado (2024 mode)");
         return false;
      }
      
      // 2. Verificar drawdown diário
      if(!CheckDailyDrawdown()) return false;
      
      // 3. Verificar perdas consecutivas
      if(!CheckConsecutiveLosses()) return false;
   }
   
   // Verificar spread
   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(spread > MaxSpread * 10) 
   {
      Print("Spread alto: ", spread);
      return false;
   }
   
   // Cooldown entre trades
   if(lastTradeTime > 0)
   {
      double minutes = (TimeCurrent() - lastTradeTime) / 60.0;
      double minCooldown = is2024Conditions ? 20.0 : 15.0;
      
      if(minutes < minCooldown) return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| OBTER VALORES DOS INDICADORES                                  |
//+------------------------------------------------------------------+
double GetRSI()
{
   double rsi[1];
   return (CopyBuffer(handleRSI, 0, 0, 1, rsi) == 1) ? rsi[0] : 50.0;
}

double GetEMAFast()
{
   double ema[1];
   return (CopyBuffer(handleEMAFast, 0, 0, 1, ema) == 1) ? ema[0] : 0;
}

double GetEMASlow()
{
   double ema[1];
   return (CopyBuffer(handleEMASlow, 0, 0, 1, ema) == 1) ? ema[0] : 0;
}

//+------------------------------------------------------------------+
//| GERAR SINAL - MANTÉM ORIGINAL                                  |
//+------------------------------------------------------------------+
int GenerateSignal()
{
   double rsi = GetRSI();
   double emaFast = GetEMAFast();
   double emaSlow = GetEMASlow();
   
   if(emaFast == 0 || emaSlow == 0) return -1;
   
   bool trendBullish = (emaFast > emaSlow);
   
   // LÓGICA ORIGINAL (não mudar)
   if(rsi < RSIOversold && trendBullish)
   {
      Print("SINAL BUY: RSI=", rsi);
      return ORDER_TYPE_BUY;
   }
   
   if(rsi > RSIOverbought && !trendBullish)
   {
      Print("SINAL SELL: RSI=", rsi);
      return ORDER_TYPE_SELL;
   }
   
   return -1;
}

//+------------------------------------------------------------------+
//| CALCULAR LOTE COM MODO 2024                                    |
//+------------------------------------------------------------------+
double CalculateLot()
{
   double lot = LotSize;
   
   if(UseDynamicLot)
   {
      double balance = AccountInfoDouble(ACCOUNT_EQUITY);
      double riskAmount = balance * (RiskPercent / 100.0);
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      
      double slPips = StopLossPips;
      
      // Aplicar multiplicador 2024 se ativo
      if(is2024Conditions && Enable2024SurvivalMode)
         slPips *= SLMultiplier2024;
      
      double riskPerLot = slPips * point * tickValue / tickSize;
      if(riskPerLot > 0)
      {
         lot = riskAmount / riskPerLot;
         double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
         lot = MathFloor(lot / lotStep) * lotStep;
         
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
         lot = MathMax(minLot, MathMin(maxLot, lot));
      }
   }
   
   // Aplicar multiplicador 2024
   if(is2024Conditions && Enable2024SurvivalMode)
   {
      lot *= LotMultiplier2024;
      Print("MODO 2024: Lote ajustado x", LotMultiplier2024, " = ", lot);
   }
   
   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| GERENCIAR POSIÇÃO APÓS ABERTURA                               |
//+------------------------------------------------------------------+
void ManagePosition(ulong ticket)
{
   if(!is2024Conditions || !Enable2024SurvivalMode) return;
   
   if(PositionSelectByTicket(ticket))
   {
      int type = (int)PositionGetInteger(POSITION_TYPE);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      double volume = PositionGetDouble(POSITION_VOLUME);
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      
      // Calcular lucro em pips
      double profitPips = 0;
      if(type == POSITION_TYPE_BUY)
         profitPips = (currentPrice - openPrice) / point;
      else
         profitPips = (openPrice - currentPrice) / point;
      
      // 1. MOVER PARA BREAKEVEN
      if(UseBreakeven2024 && profitPips >= BreakevenTrigger)
      {
         if((type == POSITION_TYPE_BUY && currentSL < openPrice) ||
            (type == POSITION_TYPE_SELL && currentSL > openPrice))
         {
            trade.PositionModify(ticket, openPrice, currentTP);
            Print("Breakeven ativado para ticket ", ticket);
         }
      }
      
      // 2. FECHAMENTOS PARCIAIS
      if(UsePartialCloses2024)
      {
         // Fechar 50% aos 50 pips
         if(profitPips >= Close50at && volume > 0.1)
         {
            double closeVolume = volume * 0.5;
            trade.PositionClosePartial(ticket, closeVolume);
            Print("Fechado 50% (", closeVolume, " lots) aos ", profitPips, " pips");
         }
         
         // Fechar 30% aos 100 pips
         if(profitPips >= Close30at && volume > 0.06)
         {
            double closeVolume = volume * 0.3;
            trade.PositionClosePartial(ticket, closeVolume);
            Print("Fechado 30% (", closeVolume, " lots) aos ", profitPips, " pips");
         }
      }
   }
}

//+------------------------------------------------------------------+
//| EXECUTAR TRADE                                                 |
//+------------------------------------------------------------------+
bool ExecuteTrade(int type)
{
   double lot = CalculateLot();
   double price = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                                           : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double slPips = StopLossPips;
   double tpPips = TakeProfitPips;
   
   // Aplicar ajustes 2024
   if(is2024Conditions && Enable2024SurvivalMode)
   {
      slPips *= SLMultiplier2024;
      tpPips *= TPMultiplier2024;
   }
   
   double sl = (type == ORDER_TYPE_BUY) ? price - (slPips * point)
                                        : price + (slPips * point);
   double tp = (type == ORDER_TYPE_BUY) ? price + (tpPips * point)
                                        : price - (tpPips * point);
   
   MqlTradeRequest request = {};
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type = (ENUM_ORDER_TYPE)type;
   request.price = price;
   request.sl = sl;
   request.tp = tp;
   request.deviation = 10;
   request.magic = MagicNumber;
   request.comment = is2024Conditions ? "2024_SURVIVAL" : "NORMAL";
   request.type_filling = ORDER_FILLING_IOC;
   
   MqlTradeResult result;
   if(OrderSend(request, result) && result.retcode == TRADE_RETCODE_DONE)
   {
      lastTradeTime = TimeCurrent();
      tradesToday++;
      
      Print("Trade #", tradesToday, 
            (is2024Conditions ? " [2024 MODE]" : " [NORMAL]"), " | ",
            (type == ORDER_TYPE_BUY ? "BUY" : "SELL"),
            " | Lote: ", lot, " | SL: ", slPips, "p | TP: ", tpPips, "p");
      
      // Iniciar gerenciamento para modo 2024
      if(is2024Conditions && Enable2024SurvivalMode)
         EventSetTimer(30); // Verificar a cada 30 segundos
      
      return true;
   }
   
   Print("Erro no trade: ", GetLastError());
   return false;
}

//+------------------------------------------------------------------+
//| ON TIMER - GERENCIAR POSIÇÕES 2024                            |
//+------------------------------------------------------------------+
void OnTimer()
{
   if(!is2024Conditions || !Enable2024SurvivalMode)
   {
      EventKillTimer();
      return;
   }
   
   // Gerenciar todas as posições abertas
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
      {
         ManagePosition(ticket);
      }
   }
}

//+------------------------------------------------------------------+
//| ON TICK                                                         |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!CanTrade()) return;
   
   int signal = GenerateSignal();
   if(signal != -1)
   {
      if(ExecuteTrade(signal))
      {
         Print("=== STATUS ===");
         Print("Trades hoje: ", tradesToday, "/", MaxTradesPerDay);
         Print("Perdas hoje: ", losingTradesToday, "/", MaxDailyLoss2024);
         Print("Modo: ", is2024Conditions ? "2024 SURVIVAL" : "NORMAL");
      }
   }
}

//+------------------------------------------------------------------+
//| DEINIT                                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(handleRSI);
   IndicatorRelease(handleEMAFast);
   IndicatorRelease(handleEMASlow);
   if(handleATR != INVALID_HANDLE) IndicatorRelease(handleATR);
   EventKillTimer();
   
   Print("=== RESUMO FINAL ===");
   Print("Total trades: ", tradesToday);
   Print("Trades perdedores: ", losingTradesToday);
   Print("Modo 2024 ativo: ", is2024Conditions ? "SIM" : "NÃO");
}
//+------------------------------------------------------------------+
