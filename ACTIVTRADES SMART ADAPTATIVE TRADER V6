//+------------------------------------------------------------------+
//|        ACTIVTRADES SMART ADAPTATIVE TRADER V6
//+------------------------------------------------------------------+
#property copyright "ACTIVTRADES SMART ADAPTATIVE TRADER V6"
#property version   "40.0"
#property description "EA: ATR relativo, cap diário, ajuste por drawdown, regime ON/OFF"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO ORIGINAL                                            |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO ORIGINAL ==="
input int      MagicNumber = 777888;
input double   RiskPercent = 0.5;
input double   MaxSpread = 10.0;
input int      MaxTradesPerDay = 5;

input group "=== ESTRATÉGIA ORIGINAL ==="
input int      RSIPeriod = 14;
input double   RSIOverbought = 68.0;
input double   RSIOversold = 33.0;
input int      EMAFastPeriod = 16;
input int      EMASlowPeriod = 200;

input group "=== RISCO ORIGINAL ==="
input double   StopLossPips = 100.0;
input double   TakeProfitPips = 150.0;

//+------------------------------------------------------------------+
//| AJUSTE DINÂMICO DE LOTES (ATR RELATIVO)                           |
//+------------------------------------------------------------------+
input group "=== AJUSTE DINÂMICO LOTES ==="
input bool     EnableDynamicLotAdjustment = true;
input double   LowVolatilityMultiplier = 0.6;
input double   HighVolatilityMultiplier = 1.2;
input double   LowATR_Percent = 0.15;   // ATR < 0.15% do preço
input double   HighATR_Percent = 0.35;  // ATR > 0.35% do preço

//+------------------------------------------------------------------+
//| HUMANIZAÇÃO EXECUÇÃO (M15 SAFE)                                   |
//+------------------------------------------------------------------+
input group "=== EXECUÇÃO HUMANIZADA ==="
input bool     EnableHumanDelay = true;
input int      MinDelaySeconds = 3;
input int      MaxDelaySeconds = 15;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO PROP FIRM                                            |
//+------------------------------------------------------------------+
input group "=== PROP FIRM SETTINGS ==="
enum PropFirm {FTMO=0, ALPHA=1, FUNDEDNEXT=2};
input PropFirm SelectedPropFirm = FTMO;

// Limites diários e máximos
double DailyDDLimit, MaxDDLimit, MaxConsecutiveLosses;
double DailyDD = 0;
double MaxDD = 0;
int ConsecutiveLosses = 0;

//+------------------------------------------------------------------+
//| VARIÁVEIS                                                        |
//+------------------------------------------------------------------+
int handleRSI, handleEMAFast, handleEMASlow, handleATR;
datetime lastTradeTime = 0;
datetime lastBar = 0;
datetime lastDayChecked = 0;
int tradesToday = 0;
bool delayActive = false;
datetime signalTime = 0;
int pendingSignal = -1;
string Regime = "ON"; // ON, OFF, ON FULL, ON LIGHT

//+------------------------------------------------------------------+
//| INIT                                                             |
//+------------------------------------------------------------------+
int OnInit()
{
   handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleATR = iATR(_Symbol, _Period, 14);
   MathSrand((uint)TimeLocal());

   // Configura limites por prop firm
   switch(SelectedPropFirm)
   {
      case FTMO:
         DailyDDLimit = 0.02; // 2%
         MaxDDLimit   = 0.10; // 10%
         MaxConsecutiveLosses = 2;
         break;
      case ALPHA:
         DailyDDLimit = 0.015; // 1.5%
         MaxDDLimit   = 0.08;  // 8%
         MaxConsecutiveLosses = 2;
         break;
      case FUNDEDNEXT:
         DailyDDLimit = 0.025; // 2.5%
         MaxDDLimit   = 0.12;  // 12%
         MaxConsecutiveLosses = 2;
         break;
   }

   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| UTILIDADES                                                       |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   return PositionsTotal() > 0;
}

void ResetDailyStats()
{
   MqlDateTime dt;
   TimeCurrent(dt);
   if(lastDayChecked != dt.day)
   {
      lastDayChecked = dt.day;
      tradesToday = 0;
      DailyDD = 0;
      ConsecutiveLosses = 0;
      Regime = "ON";
   }
}

bool CanTrade()
{
   ResetDailyStats();

   if(Regime == "OFF") return false;
   if(HasOpenPosition()) return false;
   if(tradesToday >= MaxTradesPerDay) return false;

   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(spread > MaxSpread * 10) return false;

   if(lastTradeTime > 0)
   {
      if((TimeCurrent() - lastTradeTime) < 1800) return false;
   }

   return true;
}

//+------------------------------------------------------------------+
//| SINAL ORIGINAL                                                   |
//+------------------------------------------------------------------+
int GenerateSignal()
{
   double rsi[1], emaFast[1], emaSlow[1];
   if(CopyBuffer(handleRSI, 0, 0, 1, rsi) != 1) return -1;
   if(CopyBuffer(handleEMAFast, 0, 0, 1, emaFast) != 1) return -1;
   if(CopyBuffer(handleEMASlow, 0, 0, 1, emaSlow) != 1) return -1;

   bool bullish = emaFast[0] > emaSlow[0];
   if(rsi[0] < RSIOversold && bullish) return ORDER_TYPE_BUY;
   if(rsi[0] > RSIOverbought && !bullish) return ORDER_TYPE_SELL;

   return -1;
}

//+------------------------------------------------------------------+
//| MULTIPLICADOR ATR RELATIVO                                       |
//+------------------------------------------------------------------+
double CalculateLotMultiplier()
{
   if(!EnableDynamicLotAdjustment) return 1.0;

   double atr[1];
   if(CopyBuffer(handleATR, 0, 0, 1, atr) != 1) return 1.0;

   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double atrPercent = (atr[0] / price) * 100.0;

   if(atrPercent < LowATR_Percent) return LowVolatilityMultiplier;
   if(atrPercent > HighATR_Percent) return HighVolatilityMultiplier;

   return 1.0;
}

//+------------------------------------------------------------------+
//| LOTE                                                             |
//+------------------------------------------------------------------+
double CalculateLot()
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskAmount = equity * (RiskPercent / 100.0);

   // Ajuste por drawdown
   double currentDD = (AccountInfoDouble(ACCOUNT_BALANCE) - equity)/AccountInfoDouble(ACCOUNT_BALANCE);
   if(currentDD > 0.05) riskAmount *= 0.3;
   else if(currentDD > 0.03) riskAmount *= 0.5;

   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double point     = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   double riskPerLot = StopLossPips * point * tickValue / tickSize;
   if(riskPerLot <= 0) return 0.01;

   double lot = riskAmount / riskPerLot;
   lot *= CalculateLotMultiplier();

   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   lot = MathFloor(lot / step) * step;
   lot = MathMax(minLot, MathMin(maxLot, lot));

   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| EXECUTAR                                                        |
//+------------------------------------------------------------------+
void ExecuteTrade(int type)
{
   double lot = CalculateLot();
   if(lot <= 0) return;

   double price = (type == ORDER_TYPE_BUY)
                  ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                  : SymbolInfoDouble(_Symbol, SYMBOL_BID);

   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double sl = (type == ORDER_TYPE_BUY)
               ? price - StopLossPips * point
               : price + StopLossPips * point;

   double tp = (type == ORDER_TYPE_BUY)
               ? price + TakeProfitPips * point
               : price - TakeProfitPips * point;

   trade.SetExpertMagicNumber(MagicNumber);
   if(trade.PositionOpen(_Symbol, (ENUM_ORDER_TYPE)type, lot, price, sl, tp))
   {
      lastTradeTime = TimeCurrent();
      tradesToday++;
   }
}

//+------------------------------------------------------------------+
//| ATUALIZA REGIME / MONITORA DD                                     |
//+------------------------------------------------------------------+
void UpdateRegime(double profit)
{
   DailyDD += profit;
   MaxDD = MathMax(MaxDD, AccountInfoDouble(ACCOUNT_BALANCE) - AccountInfoDouble(ACCOUNT_EQUITY));

   // Consecutive losses
   if(profit < 0) ConsecutiveLosses++;
   else ConsecutiveLosses = 0;

   if(DailyDD <= -DailyDDLimit*AccountInfoDouble(ACCOUNT_BALANCE) || 
      MaxDD >= MaxDDLimit*AccountInfoDouble(ACCOUNT_BALANCE) ||
      ConsecutiveLosses >= MaxConsecutiveLosses)
      Regime = "OFF";
   else if(DailyDD > -DailyDDLimit*AccountInfoDouble(ACCOUNT_BALANCE)/2)
      Regime = "ON FULL";
   else
      Regime = "ON LIGHT";
}

//+------------------------------------------------------------------+
//| EXIBIR REGIME NO GRÁFICO                                         |
//+------------------------------------------------------------------+
void DrawRegime()
{
   string txt = "Regime: "+Regime;
   int x = 20;
   int y = 20;
   color c = clrLime;
   if(Regime=="OFF") c=clrRed;
   else if(Regime=="ON LIGHT") c=clrYellow;
   else if(Regime=="ON FULL") c=clrGreen;
   Comment(txt);
}

//+------------------------------------------------------------------+
//| ON TICK                                                          |
//+------------------------------------------------------------------+
void OnTick()
{
   datetime barTime = iTime(_Symbol, _Period, 0);
   if(barTime != lastBar)
   {
      lastBar = barTime;
      if(!CanTrade()) 
      {
         DrawRegime();
         return;
      }

      int signal = GenerateSignal();
      if(signal != -1)
      {
         if(EnableHumanDelay)
         {
            delayActive = true;
            pendingSignal = signal;
            signalTime = TimeCurrent() +
                         MathRand() % (MaxDelaySeconds - MinDelaySeconds + 1)
                         + MinDelaySeconds;
         }
         else
         {
            ExecuteTrade(signal);
         }
      }
   }

   if(delayActive && TimeCurrent() >= signalTime)
   {
      if(CanTrade())
         ExecuteTrade(pendingSignal);

      delayActive = false;
      pendingSignal = -1;
   }

   DrawRegime();
}
