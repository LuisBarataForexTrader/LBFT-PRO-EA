//+------------------------------------------------------------------+
//|                 SMART ADAPTIVE TRADER V3 - ALPHACAPITAL EURUSD 15M                        |
//|    Ajusta lotes baseado na volatilidade, NÃO muda estratégia  |
//+------------------------------------------------------------------+
#property copyright "Smart Lot Size EA"
#property version   "37.0"
#property description "Apenas ajusta lotes dinamicamente - estratégia original"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO ORIGINAL (NÃO MEXER)                             |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO ORIGINAL ==="
input int      MagicNumber = 777888;
input double   BaseLotSize = 0.5;
input double   RiskPercent = 0.5;
input double   MaxSpread = 10.0;
input int      MaxTradesPerDay = 5;

input group "=== ESTRATÉGIA ORIGINAL ==="
input int      RSIPeriod = 14;
input double   RSIOverbought = 68.0;
input double   RSIOversold = 33.0;
input int      EMAFastPeriod = 16;
input int      EMASlowPeriod = 200;

input group "=== RISCO ORIGINAL ==="
input double   StopLossPips = 100.0;
input double   TakeProfitPips = 150.0;

//+------------------------------------------------------------------+
//| AJUSTE DINÂMICO DE LOTES (APENAS ISSO)                       |
//+------------------------------------------------------------------+
input group "=== AJUSTE DINÂMICO LOTES ==="
input bool     EnableDynamicLotAdjustment = true;
input double   LowVolatilityMultiplier = 0.6;   // Lotes MENORES em baixa volatilidade
input double   HighVolatilityMultiplier = 1.2;  // Lotes MAIORES em alta volatilidade
input double   LowATR_Threshold = 0.00020;      // ATR baixo (condições 2024)
input double   HighATR_Threshold = 0.00040;     // ATR alto (condições normais)

//+------------------------------------------------------------------+
//| VARIÁVEIS                                                      |
//+------------------------------------------------------------------+
int handleRSI, handleEMAFast, handleEMASlow, handleATR;
datetime lastTradeTime = 0;
int tradesToday = 0;
datetime lastDayChecked = 0;
double currentLotMultiplier = 1.0;

//+------------------------------------------------------------------+
//| INICIALIZAÇÃO                                                  |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("=== SMART LOT SIZE EA ===");
   Print("ESTRATÉGIA: Mantém ORIGINAL, apenas ajusta lotes dinamicamente");
   
   handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleATR = iATR(_Symbol, _Period, 14);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| CALCULAR MULTIPLICADOR DE LOTE BASEADO NO ATR                |
//+------------------------------------------------------------------+
double CalculateLotMultiplier()
{
   if(!EnableDynamicLotAdjustment) return 1.0;
   
   double atrValue[1];
   if(CopyBuffer(handleATR, 0, 0, 1, atrValue) == 1)
   {
      if(atrValue[0] < LowATR_Threshold)
      {
         // Condições 2024: volatilidade BAIXA
         currentLotMultiplier = LowVolatilityMultiplier;
         Print("Low volatility: ATR=", atrValue[0], " -> Lot x", currentLotMultiplier);
         return currentLotMultiplier;
      }
      else if(atrValue[0] > HighATR_Threshold)
      {
         // Condições normais/altas: volatilidade ALTA
         currentLotMultiplier = HighVolatilityMultiplier;
         Print("High volatility: ATR=", atrValue[0], " -> Lot x", currentLotMultiplier);
         return currentLotMultiplier;
      }
   }
   
   currentLotMultiplier = 1.0;
   return currentLotMultiplier;
}

//+------------------------------------------------------------------+
//| FUNÇÕES BÁSICAS (ORIGINAIS)                                  |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   return PositionsTotal() > 0;
}

void ResetDailyStats()
{
   MqlDateTime dt;
   TimeCurrent(dt);
   
   if(lastDayChecked != dt.day)
   {
      lastDayChecked = dt.day;
      tradesToday = 0;
   }
}

bool CanTrade()
{
   ResetDailyStats();
   
   if(HasOpenPosition()) return false;
   if(tradesToday >= MaxTradesPerDay) return false;
   
   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(spread > MaxSpread * 10) return false;
   
   if(lastTradeTime > 0)
   {
      double minutes = (TimeCurrent() - lastTradeTime) / 60.0;
      if(minutes < 30.0) return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| GERAR SINAL (ORIGINAL - NÃO MUDAR)                           |
//+------------------------------------------------------------------+
int GenerateSignal()
{
   double rsi[1], emaFast[1], emaSlow[1];
   
   if(CopyBuffer(handleRSI, 0, 0, 1, rsi) != 1) return -1;
   if(CopyBuffer(handleEMAFast, 0, 0, 1, emaFast) != 1) return -1;
   if(CopyBuffer(handleEMASlow, 0, 0, 1, emaSlow) != 1) return -1;
   
   bool trendBullish = (emaFast[0] > emaSlow[0]);
   
   if(rsi[0] < RSIOversold && trendBullish)
   {
      Print("BUY: RSI=", rsi[0]);
      return ORDER_TYPE_BUY;
   }
   
   if(rsi[0] > RSIOverbought && !trendBullish)
   {
      Print("SELL: RSI=", rsi[0]);
      return ORDER_TYPE_SELL;
   }
   
   return -1;
}

//+------------------------------------------------------------------+
//| CALCULAR LOTE DINÂMICO                                        |
//+------------------------------------------------------------------+
double CalculateLot()
{
   double lot = BaseLotSize;
   
   // Calcular baseado no risco
   double balance = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskAmount = balance * (RiskPercent / 100.0);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double riskPerLot = StopLossPips * point * tickValue / tickSize;
   if(riskPerLot > 0)
   {
      lot = riskAmount / riskPerLot;
      double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      lot = MathFloor(lot / lotStep) * lotStep;
      
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
      lot = MathMax(minLot, MathMin(maxLot, lot));
   }
   
   // Aplicar multiplicador dinâmico
   double multiplier = CalculateLotMultiplier();
   lot *= multiplier;
   
   Print("Lot: ", lot, " (Base: ", BaseLotSize, " x ", multiplier, ")");
   
   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| EXECUTAR TRADE (ORIGINAL)                                     |
//+------------------------------------------------------------------+
bool ExecuteTrade(int signalType)
{
   double lot = CalculateLot();
   double price = (signalType == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                                                 : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double sl = 0, tp = 0;
   
   if(signalType == ORDER_TYPE_BUY)
   {
      sl = price - (StopLossPips * point);
      tp = price + (TakeProfitPips * point);
   }
   else
   {
      sl = price + (StopLossPips * point);
      tp = price - (TakeProfitPips * point);
   }
   
   MqlTradeRequest request = {};
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type = (ENUM_ORDER_TYPE)signalType;
   request.price = price;
   request.sl = sl;
   request.tp = tp;
   request.deviation = 10;
   request.magic = MagicNumber;
   request.comment = "SMART_LOT";
   request.type_filling = ORDER_FILLING_IOC;
   
   MqlTradeResult result;
   if(OrderSend(request, result) && result.retcode == TRADE_RETCODE_DONE)
   {
      lastTradeTime = TimeCurrent();
      tradesToday++;
      
      Print("Trade #", tradesToday, " ", (signalType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
      Print("Lot: ", lot, " SL: ", StopLossPips, "p TP: ", TakeProfitPips, "p");
      
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| ON TICK                                                        |
//+------------------------------------------------------------------+
void OnTick()
{
   static datetime lastBar = 0;
   datetime currentBar = iTime(_Symbol, _Period, 0);
   
   if(lastBar == currentBar) return;
   lastBar = currentBar;
   
   if(!CanTrade()) return;
   
   int signal = GenerateSignal();
   if(signal != -1)
   {
      ExecuteTrade(signal);
   }
}

//+------------------------------------------------------------------+
//| DEINIT                                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("=== FINAL ===");
   Print("Total trades: ", tradesToday);
   Print("Avg lot multiplier: ", currentLotMultiplier);
}
//+------------------------------------------------------------------+
