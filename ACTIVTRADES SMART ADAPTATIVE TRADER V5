//+------------------------------------------------------------------+
//|        ACTIVTRADES SMART ADAPTATIVE TRADER V5        |
//+------------------------------------------------------------------+
#property copyright "FUNDEDNEXT SMART ADAPTATIVE TRADER V5"
#property version   "39.0"
#property description "PropSafe EA: ATR relativo, cap diÃ¡rio, ajuste por drawdown"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| CONFIGURAÇÃO ORIGINAL                                            |
//+------------------------------------------------------------------+
input group "=== CONFIGURAÇÃO ORIGINAL ==="
input int      MagicNumber = 777888;
input double   RiskPercent = 0.5;
input double   MaxSpread = 10.0;
input int      MaxTradesPerDay = 5;

input group "=== ESTRATÉGIA ORIGINAL ==="
input int      RSIPeriod = 14;
input double   RSIOverbought = 68.0;
input double   RSIOversold = 33.0;
input int      EMAFastPeriod = 16;
input int      EMASlowPeriod = 200;

input group "=== RISCO ORIGINAL ==="
input double   StopLossPips = 100.0;
input double   TakeProfitPips = 150.0;

//+------------------------------------------------------------------+
//| AJUSTE DINÂMICO DE LOTES (ATR RELATIVO)                           |
//+------------------------------------------------------------------+
input group "=== AJUSTE DINÂMICO LOTES ==="
input bool     EnableDynamicLotAdjustment = true;
input double   LowVolatilityMultiplier = 0.6;
input double   HighVolatilityMultiplier = 1.2;
input double   LowATR_Percent = 0.15;   // ATR < 0.15% do preço
input double   HighATR_Percent = 0.35;  // ATR > 0.35% do preço

//+------------------------------------------------------------------+
//| HUMANIZAÇÃO EXECUÇÃO (M15 SAFE)                                   |
//+------------------------------------------------------------------+
input group "=== EXECUÇÃO HUMANIZADA ==="
input bool     EnableHumanDelay = true;
input int      MinDelaySeconds = 3;
input int      MaxDelaySeconds = 15;

//+------------------------------------------------------------------+
//| VARIÁVEIS                                                        |
//+------------------------------------------------------------------+
int handleRSI, handleEMAFast, handleEMASlow, handleATR;
datetime lastTradeTime = 0;
datetime lastBar = 0;
datetime lastDayChecked = 0;
int tradesToday = 0;
bool delayActive = false;
datetime signalTime = 0;
int pendingSignal = -1;

//+------------------------------------------------------------------+
//| INIT                                                             |
//+------------------------------------------------------------------+
int OnInit()
{
   handleRSI = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   handleEMAFast = iMA(_Symbol, _Period, EMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleEMASlow = iMA(_Symbol, _Period, EMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   handleATR = iATR(_Symbol, _Period, 14);
   MathSrand((uint)TimeLocal());
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| UTILIDADES                                                       |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   return PositionsTotal() > 0;
}

void ResetDailyStats()
{
   MqlDateTime dt;
   TimeCurrent(dt);
   if(lastDayChecked != dt.day)
   {
      lastDayChecked = dt.day;
      tradesToday = 0;
   }
}

bool CanTrade()
{
   ResetDailyStats();
   if(HasOpenPosition()) return false;
   if(tradesToday >= MaxTradesPerDay) return false;

   long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(spread > MaxSpread * 10) return false;

   if(lastTradeTime > 0)
   {
      if((TimeCurrent() - lastTradeTime) < 1800) return false;
   }
   return true;
}

//+------------------------------------------------------------------+
//| SINAL ORIGINAL                                                   |
//+------------------------------------------------------------------+
int GenerateSignal()
{
   double rsi[1], emaFast[1], emaSlow[1];
   if(CopyBuffer(handleRSI, 0, 0, 1, rsi) != 1) return -1;
   if(CopyBuffer(handleEMAFast, 0, 0, 1, emaFast) != 1) return -1;
   if(CopyBuffer(handleEMASlow, 0, 0, 1, emaSlow) != 1) return -1;

   bool bullish = emaFast[0] > emaSlow[0];
   if(rsi[0] < RSIOversold && bullish) return ORDER_TYPE_BUY;
   if(rsi[0] > RSIOverbought && !bullish) return ORDER_TYPE_SELL;

   return -1;
}

//+------------------------------------------------------------------+
//| MULTIPLICADOR ATR RELATIVO                                       |
//+------------------------------------------------------------------+
double CalculateLotMultiplier()
{
   if(!EnableDynamicLotAdjustment) return 1.0;

   double atr[1];
   if(CopyBuffer(handleATR, 0, 0, 1, atr) != 1) return 1.0;

   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double atrPercent = (atr[0] / price) * 100.0;

   if(atrPercent < LowATR_Percent) return LowVolatilityMultiplier;
   if(atrPercent > HighATR_Percent) return HighVolatilityMultiplier;

   return 1.0;
}

//+------------------------------------------------------------------+
//| LOTE                                                             |
//+------------------------------------------------------------------+
double CalculateLot()
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskAmount = equity * (RiskPercent / 100.0);

   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double point     = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   double riskPerLot = StopLossPips * point * tickValue / tickSize;
   if(riskPerLot <= 0) return 0.01;

   double lot = riskAmount / riskPerLot;
   lot *= CalculateLotMultiplier();

   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   lot = MathFloor(lot / step) * step;
   lot = MathMax(minLot, MathMin(maxLot, lot));

   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| EXECUTAR                                                        |
//+------------------------------------------------------------------+
void ExecuteTrade(int type)
{
   double lot = CalculateLot();
   if(lot <= 0) return;

   double price = (type == ORDER_TYPE_BUY)
                  ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                  : SymbolInfoDouble(_Symbol, SYMBOL_BID);

   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double sl = (type == ORDER_TYPE_BUY)
               ? price - StopLossPips * point
               : price + StopLossPips * point;

   double tp = (type == ORDER_TYPE_BUY)
               ? price + TakeProfitPips * point
               : price - TakeProfitPips * point;

   trade.SetExpertMagicNumber(MagicNumber);
   if(trade.PositionOpen(_Symbol, (ENUM_ORDER_TYPE)type, lot, price, sl, tp))
   {
      lastTradeTime = TimeCurrent();
      tradesToday++;
   }
}

//+------------------------------------------------------------------+
//| ON TICK                                                         |
//+------------------------------------------------------------------+
void OnTick()
{
   datetime barTime = iTime(_Symbol, _Period, 0);
   if(barTime != lastBar)
   {
      lastBar = barTime;
      if(!CanTrade()) return;

      int signal = GenerateSignal();
      if(signal != -1)
      {
         if(EnableHumanDelay)
         {
            delayActive = true;
            pendingSignal = signal;
            signalTime = TimeCurrent() +
                         MathRand() % (MaxDelaySeconds - MinDelaySeconds + 1)
                         + MinDelaySeconds;
         }
         else
         {
            ExecuteTrade(signal);
         }
      }
   }

   if(delayActive && TimeCurrent() >= signalTime)
   {
      if(CanTrade())
         ExecuteTrade(pendingSignal);

      delayActive = false;
      pendingSignal = -1;
   }
}
